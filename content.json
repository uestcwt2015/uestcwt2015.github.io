{"pages":[{"title":"404","text":"","path":"404/index.html","date":"02-25","excerpt":""},{"title":"search","text":"","path":"search/index.html","date":"02-25","excerpt":""}],"posts":[{"title":"Vue事件机制","text":"源码分析Vue事件机制vue 的事件都死通过v-on指令进行监听，这会涉及到vue是如何将template转化为render的，这里先不做讨论12345678910111213// parse.jsexport const onRE = /^@|^v-on:/...else if (onRE.test(name)) &#123; // v-on name = name.replace(onRE, '') /** * name: 事件名 * value: 回调函数 * modifiers: 事件修饰符 */ addHandler(el, name, value, modifiers, false, warn)&#125;... 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051// addHandlerexport function addHandler ( el: ASTElement, name: string, value: string, modifiers: ?ASTModifiers, important?: boolean, warn?: Function) &#123; // prevent和passive两个修饰符不能同时存在于同一个节点 if ( process.env.NODE_ENV !== 'production' &amp;&amp; warn &amp;&amp; modifiers &amp;&amp; modifiers.prevent &amp;&amp; modifiers.passive ) &#123; warn( 'passive and prevent can\\'t be used together. ' + 'Passive handler can\\'t prevent default event.' ) &#125; // check capture modifier if (modifiers &amp;&amp; modifiers.capture) &#123; delete modifiers.capture name = '!' + name // mark the event as captured &#125; if (modifiers &amp;&amp; modifiers.once) &#123; delete modifiers.once name = '~' + name // mark the event as once &#125; /* istanbul ignore if */ if (modifiers &amp;&amp; modifiers.passive) &#123; delete modifiers.passive name = '&amp;' + name // mark the event as passive &#125; let events if (modifiers &amp;&amp; modifiers.native) &#123; delete modifiers.native events = el.nativeEvents || (el.nativeEvents = &#123;&#125;) &#125; else &#123; events = el.events || (el.events = &#123;&#125;) &#125; const newHandler = &#123; value, modifiers &#125; const handlers = events[name] // 将回调注册到el上 if (Array.isArray(handlers)) &#123; important ? handlers.unshift(newHandler) : handlers.push(newHandler) &#125; else if (handlers) &#123; events[name] = important ? [newHandler, handlers] : [handlers, newHandler] &#125; else &#123; events[name] = newHandler &#125;&#125; 在合成AST时，会对events进行处理1234567// event handlersif (el.events) &#123; data += `$&#123;genHandlers(el.events, false, state.warn)&#125;,`&#125;if (el.nativeEvents) &#123; data += `$&#123;genHandlers(el.nativeEvents, true, state.warn)&#125;,`&#125; 12345678910111213141516171819202122232425// genHandlersexport function genHandlers ( events: ASTElementHandlers, isNative: boolean, warn: Function): string &#123; // 对native特殊化处理 let res = isNative ? 'nativeOn:&#123;' : 'on:&#123;' // 将事件以字符串的形式拼接在一个对象里 for (const name in events) &#123; const handler = events[name] // 提示用contextmenu代替click.right if (process.env.NODE_ENV !== 'production' &amp;&amp; name === 'click' &amp;&amp; handler &amp;&amp; handler.modifiers &amp;&amp; handler.modifiers.right ) &#123; warn( `Use \"contextmenu\" instead of \"click.right\" since right clicks ` + `do not actually fire \"click\" events.` ) &#125; res += `\"$&#123;name&#125;\":$&#123;genHandler(name, handler)&#125;,` &#125; return res.slice(0, -1) + '&#125;'&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960// genHandlerfunction genHandler ( name: string, handler: ASTElementHandler | Array&lt;ASTElementHandler&gt;): string &#123; // 没有回调则用一个空函数代替 if (!handler) &#123; return 'function()&#123;&#125;' &#125; // 回调是以数组传入 if (Array.isArray(handler)) &#123; return `[$&#123;handler.map(handler =&gt; genHandler(name, handler)).join(',')&#125;]` &#125; const isMethodPath = simplePathRE.test(handler.value) const isFunctionExpression = fnExpRE.test(handler.value) if (!handler.modifiers) &#123; return isMethodPath || isFunctionExpression ? handler.value : `function($event)&#123;$&#123;handler.value&#125;&#125;` // inline statement &#125; else &#123; let code = '' let genModifierCode = '' const keys = [] // 对事件修饰符进行处理 for (const key in handler.modifiers) &#123; if (modifierCode[key]) &#123; genModifierCode += modifierCode[key] // left/right if (keyCodes[key]) &#123; keys.push(key) &#125; &#125; else if (key === 'exact') &#123; const modifiers: ASTModifiers = (handler.modifiers: any) genModifierCode += genGuard( ['ctrl', 'shift', 'alt', 'meta'] .filter(keyModifier =&gt; !modifiers[keyModifier]) .map(keyModifier =&gt; `$event.$&#123;keyModifier&#125;Key`) .join('||') ) &#125; else &#123; keys.push(key) &#125; &#125; if (keys.length) &#123; code += genKeyFilter(keys) &#125; // Make sure modifiers like prevent and stop get executed after key filtering if (genModifierCode) &#123; code += genModifierCode &#125; const handlerCode = isMethodPath ? handler.value + '($event)' : isFunctionExpression ? `($&#123;handler.value&#125;)($event)` : handler.value return `function($event)&#123;$&#123;code&#125;$&#123;handlerCode&#125;&#125;` &#125;&#125; 事件APIVue为我们提供了四个api, 分别是$on,$off, $once,$emit 初始化事件123456789101112export function initEvents (vm: Component) &#123; // vm实例上存放event的地方 vm._events = Object.create(null) // 用来标志是否存在钩子 vm._hasHookEvent = false // 初始化父组件attached的事件 const listeners = vm.$options._parentListeners if (listeners) &#123; updateComponentListeners(vm, listeners) &#125;&#125; vm.$on用来监听当前实例上的自定义事件，该事件由$emit触发123456789101112131415161718Vue.prototype.$on = function (event: string | Array&lt;string&gt;, fn: Function): Component &#123; const vm: Component = this // 如果有多个自定义事件，会以数组的形式传递 if (Array.isArray(event)) &#123; // 遍历数组，$on每个事件 for (let i = 0, l = event.length; i &lt; l; i++) &#123; this.$on(event[i], fn) &#125; &#125; else &#123; // 在实例的_vm上注册事件，一个事件可有多个回调 (vm._events[event] || (vm._events[event] = [])).push(fn) // 有钩子时，标志位变为true，如：hook:beforeDestroy if (hookRE.test(event)) &#123; vm._hasHookEvent = true &#125; &#125; return vm&#125; vm.$off用来移除自定义事件监听器1234567891011121314151617181920212223242526272829303132333435363738Vue.prototype.$off = function (event?: string | Array&lt;string&gt;, fn?: Function): Component &#123; const vm: Component = this // 如果没有提供参数，则移除实例上所有监听器 if (!arguments.length) &#123; vm._events = Object.create(null) return vm &#125; // 移除该事件所有监听器 if (Array.isArray(event)) &#123; for (let i = 0, l = event.length; i &lt; l; i++) &#123; this.$off(event[i], fn) &#125; return vm &#125; // 特定事件 const cbs = vm._events[event] if (!cbs) &#123; return vm &#125; if (arguments.length === 1) &#123; vm._events[event] = null return vm &#125; // 如果制定了回调函数，则只移除该回调相关的监听器 if (fn) &#123; let cb let i = cbs.length while (i--) &#123; cb = cbs[i] if (cb === fn || cb.fn === fn) &#123; cbs.splice(i, 1) break &#125; &#125; &#125; return vm&#125; vm.$emit触发当前实例的事件12345678910111213141516171819202122232425262728293031Vue.prototype.$emit = function (event: string): Component &#123; const vm: Component = this // 避免使用驼峰式的事件名 if (process.env.NODE_ENV !== 'production') &#123; const lowerCaseEvent = event.toLowerCase() if (lowerCaseEvent !== event &amp;&amp; vm._events[lowerCaseEvent]) &#123; tip( `Event \"$&#123;lowerCaseEvent&#125;\" is emitted in component ` + `$&#123;formatComponentName(vm)&#125; but the handler is registered for \"$&#123;event&#125;\". ` + `Note that HTML attributes are case-insensitive and you cannot use ` + `v-on to listen to camelCase events when using in-DOM templates. ` + `You should probably use \"$&#123;hyphenate(event)&#125;\" instead of \"$&#123;event&#125;\".` ) &#125; &#125; let cbs = vm._events[event] if (cbs) &#123; cbs = cbs.length &gt; 1 ? toArray(cbs) : cbs // emit参数数组化 const args = toArray(arguments, 1) for (let i = 0, l = cbs.length; i &lt; l; i++) &#123; try &#123; // 调用注册到实例的事件回调 cbs[i].apply(vm, args) &#125; catch (e) &#123; handleError(e, vm, `event handler for \"$&#123;event&#125;\"`) &#125; &#125; &#125; return vm &#125; vm.$once监听一个自定义事件，但是只触发一次，在第一次触发之后移除监听器。 123456789101112Vue.prototype.$once = function (event: string, fn: Function): Component &#123; const vm: Component = this function on () &#123; // 移除监听器 vm.$off(event, on) // 调用回调 fn.apply(vm, arguments) &#125; on.fn = fn vm.$on(event, on) return vm&#125;","path":"2018/07/08/Vue事件机制/","date":"07-08","excerpt":"源码分析Vue事件机制"},{"title":"JavaScript Debounce & Throttle","text":"探究一下函数节流和函数去抖的原理及实现 函数去抖（Debounce）对于那些频繁触发的事件，我们期望在某段时间內只触发一次，而不是每次触发都要执行回调 简单的说就是我们忽略掉多次触发的相同事件，只关注某一次触发 自己的实现：12345678910111213function debounce(fn, delay) &#123; let timer = null; return function (...args) &#123; let context = this; clearTimeout(timer); timer = setTimeout(() =&gt; &#123; fn.apply(context, args); &#125;, delay); &#125;&#125; 原理： 通过闭包存储timer，当连续触发事件时，上一次的定时器还未执行回调就会被下一次触发给清掉，所以只会最后一次触发才会执行回调 demo","path":"2018/03/18/JavaScript-Debounce-Throttle/","date":"03-18","excerpt":"探究一下函数节流和函数去抖的原理及实现"}]}