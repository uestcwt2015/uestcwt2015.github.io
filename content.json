{"pages":[{"title":"404","text":"","path":"404/index.html","date":"02-25","excerpt":""},{"title":"search","text":"","path":"search/index.html","date":"02-25","excerpt":""}],"posts":[{"title":"策略模式","text":"基于JavaScript的设计模式第二篇 定义定义一系列的算法，把它们一个个封装起来，并且使它们能够相互替换策略模式的目的就是将算法的使用和算法的实现分开下面以表单校验为例子，实践一下策略模式 常规思路12345678910111213141516const form = &#123; name: 'Vermouth' phone: '13666666666'&#125;;function validataFunc(form) &#123; if (form.name === '') &#123; return false; &#125; if (!/(^1[3|5|8][0-9]&#123;9&#125;$)/.test(form.phone)) &#123; return false; &#125; return true;&#125; 这样做有很多缺点 校验函数复用性差 函数臃肿，if语句太多 弹性差 基于策略模式的表单校验12345678910111213141516171819202122232425262728293031323334const form = &#123; name: 'Vermouth', phone: '13666666666'&#125;// 校验规则集合const validataRules = &#123; isEmpty: val =&gt; val !== '', minLength: (val, limit) =&gt; val.length &gt;= limit, isPhone: val =&gt; /(^1[3|5|8][0-9]&#123;9&#125;$)/.test(val)&#125;;function Validator() &#123; this.result = null;&#125;Validator.prototype.add = function(val, rule, params) &#123; if (this.result === false) &#123; return; &#125; this.result = validataRules[rule](val, params);&#125;function validataFunc(form) &#123; let validator = new Validator(); validator.add(form.name, 'isEmpty'); validator.add(form.name, 'minLength', 6); validator.add(form.phone, 'isPhone'); return validator.result;&#125;validataFunc(form); 这样的好处是添加或者修改校验规则都会很方便","path":"2018/08/01/策略模式/","date":"08-01","excerpt":"基于JavaScript的设计模式第二篇"},{"title":"单例模式","text":"基于JavaScript的设计模式第一篇 定义保证一个类仅有一个实例，并提供一个访问他的全局访问点 简单实现为了实现一个类仅可以有一个实例，可以用一个字段来标识123456789101112131415161718192021222324const Singleton = function(name) &#123; this.name = name;&#125;;Singleton.prototype.sayName = function() &#123; console.log(this.name);&#125;;Singleton.getInstance = (function() &#123; let instance = null; return function(name) &#123; if (!instance) &#123; instance = new Singleton(name); &#125; return instance; &#125;&#125;());let a = Singleton.getInstance('a');let b = Singleton.getInstance('b');a.sayName(); // 'a'b.sayName(); // 'a'console.log(a === b); // true 可以看出确实只创建了一个实例，第二次并没有创建新的实例 改进1234567891011121314151617181920212223242526function Singleton(Fn) &#123; let instance = null; return function(...arg) &#123; if(!instance) &#123; instance = new Fn(...arg); &#125; return instance; &#125;;&#125;function Circle(radius) &#123; this.radius = radius;&#125;Circle.prototype.getArea = function() &#123; return 3.14 * this.radius * this.radius;&#125;let createCircle = Singleton(Circle);let circleA = createCircle(2);let circleB = createCircle(3);circleA.getArea(); // 12.56circleB.getArea(); // 12.56console.log(circleA === circleB); // true 这里实现了一个创建圆的单例模式，将Singleton分离出来，将真正的工厂函数作为回调传进去","path":"2018/07/31/单例模式/","date":"07-31","excerpt":"基于JavaScript的设计模式第一篇"},{"title":"排序算法","text":"总结一下各种常见的排序算法 冒泡排序交换相邻1234567891011121314function bubbleSort(arr) &#123; const len = arr.length; for (let i = 0; i &lt; len; i++) &#123; for (let j = 0; j &lt; len; j++) &#123; if (arr[j] &gt; arr[j+1]) &#123; let swap = arr[j+1]; arr[j+1] = arr[j]; arr[j] = swap; &#125; &#125; &#125; return arr;&#125;","path":"2018/07/21/排序算法/","date":"07-21","excerpt":"总结一下各种常见的排序算法"},{"title":"Vuex源码学习","text":"Vuex是一个专门为Vue.js框架设计的、用于对Vue.js应用程序进行状态管理的库，它借鉴了Flux、redux的基本思想，将共享的数据抽离到全局，以一个单例存放，同时利用Vue.js的响应式机制来进行高效的状态管理与更新。正是因为Vuex使用了Vue.js内部的“响应式机制”，所以Vuex是一个专门为Vue.js设计并与之高度契合的框架![image][https://vuex.vuejs.org/flow.png] 引入Vuex在vue项目中我们通常会这样引入vuex12345678import Vuex from 'vuex';Vue.use(Vuex);// 将vuex注入到vue实例中new Vue(&#123; el: '#app', store&#125;); 这实际上是通过vuex提供的install123456789101112131415// installexport function install (_Vue) &#123; // 避免重复安装 if (Vue &amp;&amp; _Vue === Vue) &#123; if (process.env.NODE_ENV !== 'production') &#123; console.error( '[vuex] already installed. Vue.use(Vuex) should be called only once.' ) &#125; return &#125; Vue = _Vue // 将vuexInit混淆进vue的beforeCreate applyMixin(Vue)&#125; install做了两件事情，避免vuex重复安装和初始化vuex Vuex初始化12345678910111213function vuexInit () &#123; const options = this.$options if (options.store) &#123; this.$store = typeof options.store === 'function' ? options.store() : options.store &#125; else if (options.parent &amp;&amp; options.parent.$store) &#123; // 从父组件获取store，保证了单一数据源 this.$store = options.parent.$store &#125;&#125; 如果当前组件是root实例，则直接从options获取store，如果不是就获取父组件的store Store先来看store的constructor1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465constructor (options = &#123;&#125;) &#123; // Auto install if it is not done yet and `window` has `Vue`. // To allow users to avoid auto-installation in some cases, // this code should be placed here. See #731 if (!Vue &amp;&amp; typeof window !== 'undefined' &amp;&amp; window.Vue) &#123; install(window.Vue) &#125; if (process.env.NODE_ENV !== 'production') &#123; assert(Vue, `must call Vue.use(Vuex) before creating a store instance.`) assert(typeof Promise !== 'undefined', `vuex requires a Promise polyfill in this browser.`) assert(this instanceof Store, `store must be called with the new operator.`) &#125; const &#123; plugins = [], strict = false &#125; = options // store internal state this._committing = false // 存放action this._actions = Object.create(null) this._actionSubscribers = [] // 存放mutation this._mutations = Object.create(null) // 存放getter this._wrappedGetters = Object.create(null) // 存放module this._modules = new ModuleCollection(options) this._modulesNamespaceMap = Object.create(null) this._subscribers = [] this._watcherVM = new Vue() // bind commit and dispatch to self const store = this // 将dispatch和commit的this绑定为store，否则会指向vm const &#123; dispatch, commit &#125; = this this.dispatch = function boundDispatch (type, payload) &#123; return dispatch.call(store, type, payload) &#125; this.commit = function boundCommit (type, payload, options) &#123; return commit.call(store, type, payload, options) &#125; // strict mode this.strict = strict const state = this._modules.root.state // 初始化根module，同时递归初始化子module // 收集所有getter, action, mutation（包括子module） installModule(this, state, [], this._modules.root) // 通过vm使store响应式化 resetStoreVM(this, state) // 调用插件 plugins.forEach(plugin =&gt; plugin(this)) // devtools if (Vue.config.devtools) &#123; devtoolPlugin(this) &#125;&#125; 接下来看看vuex如何安装module 123456789101112131415161718192021222324252627282930313233343536373839404142// installModulefunction installModule (store, rootState, path, module, hot) &#123; const isRoot = !path.length const namespace = store._modules.getNamespace(path) // register in namespace map // 如果开启了命名空间就将模块注册到map里 if (module.namespaced) &#123; store._modulesNamespaceMap[namespace] = module &#125; // set state if (!isRoot &amp;&amp; !hot) &#123; const parentState = getNestedState(rootState, path.slice(0, -1)) const moduleName = path[path.length - 1] store._withCommit(() =&gt; &#123; Vue.set(parentState, moduleName, module.state) &#125;) &#125; const local = module.context = makeLocalContext(store, namespace, path) module.forEachMutation((mutation, key) =&gt; &#123; const namespacedType = namespace + key registerMutation(store, namespacedType, mutation, local) &#125;) module.forEachAction((action, key) =&gt; &#123; const type = action.root ? key : namespace + key const handler = action.handler || action registerAction(store, type, handler, local) &#125;) module.forEachGetter((getter, key) =&gt; &#123; const namespacedType = namespace + key registerGetter(store, namespacedType, getter, local) &#125;) module.forEachChild((child, key) =&gt; &#123; installModule(store, rootState, path.concat(key), child, hot) &#125;)&#125;","path":"2018/07/18/Vuex源码学习/","date":"07-18","excerpt":"Vuex是一个专门为Vue.js框架设计的、用于对Vue.js应用程序进行状态管理的库，它借鉴了Flux、redux的基本思想，将共享的数据抽离到全局，以一个单例存放，同时利用Vue.js的响应式机制来进行高效的状态管理与更新。正是因为Vuex使用了Vue.js内部的“响应式机制”，所以Vuex是一个专门为Vue.js设计并与之高度契合的框架"},{"title":"Vue事件机制","text":"源码分析Vue事件机制vue 的事件都是通过v-on指令进行监听，这会涉及到vue是如何将template转化为render的，这里先不做讨论12345678910111213// parse.jsexport const onRE = /^@|^v-on:/...else if (onRE.test(name)) &#123; // v-on name = name.replace(onRE, '') /** * name: 事件名 * value: 回调函数 * modifiers: 事件修饰符 */ addHandler(el, name, value, modifiers, false, warn)&#125;... 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152// addHandlerexport function addHandler ( el: ASTElement, name: string, value: string, modifiers: ?ASTModifiers, important?: boolean, warn?: Function) &#123; // prevent和passive两个修饰符不能同时存在于同一个节点 if ( process.env.NODE_ENV !== 'production' &amp;&amp; warn &amp;&amp; modifiers &amp;&amp; modifiers.prevent &amp;&amp; modifiers.passive ) &#123; warn( 'passive and prevent can\\'t be used together. ' + 'Passive handler can\\'t prevent default event.' ) &#125; // check capture modifier if (modifiers &amp;&amp; modifiers.capture) &#123; delete modifiers.capture name = '!' + name // mark the event as captured &#125; if (modifiers &amp;&amp; modifiers.once) &#123; delete modifiers.once name = '~' + name // mark the event as once &#125; /* istanbul ignore if */ if (modifiers &amp;&amp; modifiers.passive) &#123; delete modifiers.passive name = '&amp;' + name // mark the event as passive &#125; let events if (modifiers &amp;&amp; modifiers.native) &#123; // 对native的事件特殊处理 delete modifiers.native events = el.nativeEvents || (el.nativeEvents = &#123;&#125;) &#125; else &#123; events = el.events || (el.events = &#123;&#125;) &#125; const newHandler = &#123; value, modifiers &#125; const handlers = events[name] // 将回调注册到el上 if (Array.isArray(handlers)) &#123; important ? handlers.unshift(newHandler) : handlers.push(newHandler) &#125; else if (handlers) &#123; events[name] = important ? [newHandler, handlers] : [handlers, newHandler] &#125; else &#123; events[name] = newHandler &#125;&#125; 在合成AST时，会对events进行处理1234567// event handlersif (el.events) &#123; data += `$&#123;genHandlers(el.events, false, state.warn)&#125;,`&#125;if (el.nativeEvents) &#123; data += `$&#123;genHandlers(el.nativeEvents, true, state.warn)&#125;,`&#125; 12345678910111213141516171819202122232425// genHandlersexport function genHandlers ( events: ASTElementHandlers, isNative: boolean, warn: Function): string &#123; // 对native特殊化处理 let res = isNative ? 'nativeOn:&#123;' : 'on:&#123;' // 将事件以字符串的形式拼接在一个对象里 for (const name in events) &#123; const handler = events[name] // 提示用contextmenu代替click.right if (process.env.NODE_ENV !== 'production' &amp;&amp; name === 'click' &amp;&amp; handler &amp;&amp; handler.modifiers &amp;&amp; handler.modifiers.right ) &#123; warn( `Use \"contextmenu\" instead of \"click.right\" since right clicks ` + `do not actually fire \"click\" events.` ) &#125; res += `\"$&#123;name&#125;\":$&#123;genHandler(name, handler)&#125;,` &#125; return res.slice(0, -1) + '&#125;'&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960// genHandlerfunction genHandler ( name: string, handler: ASTElementHandler | Array&lt;ASTElementHandler&gt;): string &#123; // 没有回调则用一个空函数代替 if (!handler) &#123; return 'function()&#123;&#125;' &#125; // 回调是以数组传入 if (Array.isArray(handler)) &#123; return `[$&#123;handler.map(handler =&gt; genHandler(name, handler)).join(',')&#125;]` &#125; const isMethodPath = simplePathRE.test(handler.value) const isFunctionExpression = fnExpRE.test(handler.value) if (!handler.modifiers) &#123; return isMethodPath || isFunctionExpression ? handler.value : `function($event)&#123;$&#123;handler.value&#125;&#125;` // inline statement &#125; else &#123; let code = '' let genModifierCode = '' const keys = [] // 对事件修饰符进行处理 for (const key in handler.modifiers) &#123; if (modifierCode[key]) &#123; genModifierCode += modifierCode[key] // left/right if (keyCodes[key]) &#123; keys.push(key) &#125; &#125; else if (key === 'exact') &#123; const modifiers: ASTModifiers = (handler.modifiers: any) genModifierCode += genGuard( ['ctrl', 'shift', 'alt', 'meta'] .filter(keyModifier =&gt; !modifiers[keyModifier]) .map(keyModifier =&gt; `$event.$&#123;keyModifier&#125;Key`) .join('||') ) &#125; else &#123; keys.push(key) &#125; &#125; if (keys.length) &#123; code += genKeyFilter(keys) &#125; // Make sure modifiers like prevent and stop get executed after key filtering if (genModifierCode) &#123; code += genModifierCode &#125; const handlerCode = isMethodPath ? handler.value + '($event)' : isFunctionExpression ? `($&#123;handler.value&#125;)($event)` : handler.value return `function($event)&#123;$&#123;code&#125;$&#123;handlerCode&#125;&#125;` &#125;&#125; 在Virtual DOM 渲染成真实DOM时会绑定事件1234567891011121314151617181920212223242526272829let target: HTMLElementfunction add ( event: string, handler: Function, once: boolean, capture: boolean, passive: boolean) &#123; if (once) &#123; const oldHandler = handler const _target = target // save current target element in closure handler = function (ev) &#123; const res = arguments.length === 1 ? oldHandler(ev) : oldHandler.apply(null, arguments) if (res !== null) &#123; remove(event, handler, capture, _target) &#125; &#125; &#125; target.addEventListener( event, handler, supportsPassive ? &#123; capture, passive &#125; : capture )&#125; 事件APIVue为我们提供了四个api, 分别是$on$off$once$emit 初始化事件123456789101112export function initEvents (vm: Component) &#123; // vm实例上存放event的地方 vm._events = Object.create(null) // 用来标志是否存在钩子 vm._hasHookEvent = false // _parentListeners里放的是注册在组件上的且不是native的事件 const listeners = vm.$options._parentListeners if (listeners) &#123; updateComponentListeners(vm, listeners) &#125;&#125; vm.$on用来监听当前实例上的自定义事件，该事件由$emit触发123456789101112131415161718Vue.prototype.$on = function (event: string | Array&lt;string&gt;, fn: Function): Component &#123; const vm: Component = this // 如果有多个自定义事件，会以数组的形式传递 if (Array.isArray(event)) &#123; // 遍历数组，$on每个事件 for (let i = 0, l = event.length; i &lt; l; i++) &#123; this.$on(event[i], fn) &#125; &#125; else &#123; // 在实例的_vm上注册事件，一个事件可有多个回调 (vm._events[event] || (vm._events[event] = [])).push(fn) // 有钩子时，标志位变为true，如：hook:beforeDestroy if (hookRE.test(event)) &#123; vm._hasHookEvent = true &#125; &#125; return vm&#125; vm.$off用来移除自定义事件监听器1234567891011121314151617181920212223242526272829303132333435363738Vue.prototype.$off = function (event?: string | Array&lt;string&gt;, fn?: Function): Component &#123; const vm: Component = this // 如果没有提供参数，则移除实例上所有监听器 if (!arguments.length) &#123; vm._events = Object.create(null) return vm &#125; // 移除该事件所有监听器 if (Array.isArray(event)) &#123; for (let i = 0, l = event.length; i &lt; l; i++) &#123; this.$off(event[i], fn) &#125; return vm &#125; // 特定事件 const cbs = vm._events[event] if (!cbs) &#123; return vm &#125; if (arguments.length === 1) &#123; vm._events[event] = null return vm &#125; // 如果制定了回调函数，则只移除该回调相关的监听器 if (fn) &#123; let cb let i = cbs.length while (i--) &#123; cb = cbs[i] if (cb === fn || cb.fn === fn) &#123; cbs.splice(i, 1) break &#125; &#125; &#125; return vm&#125; vm.$emit触发当前实例的事件12345678910111213141516171819202122232425262728293031Vue.prototype.$emit = function (event: string): Component &#123; const vm: Component = this // 避免使用驼峰式的事件名 if (process.env.NODE_ENV !== 'production') &#123; const lowerCaseEvent = event.toLowerCase() if (lowerCaseEvent !== event &amp;&amp; vm._events[lowerCaseEvent]) &#123; tip( `Event \"$&#123;lowerCaseEvent&#125;\" is emitted in component ` + `$&#123;formatComponentName(vm)&#125; but the handler is registered for \"$&#123;event&#125;\". ` + `Note that HTML attributes are case-insensitive and you cannot use ` + `v-on to listen to camelCase events when using in-DOM templates. ` + `You should probably use \"$&#123;hyphenate(event)&#125;\" instead of \"$&#123;event&#125;\".` ) &#125; &#125; let cbs = vm._events[event] if (cbs) &#123; cbs = cbs.length &gt; 1 ? toArray(cbs) : cbs // emit参数数组化 const args = toArray(arguments, 1) for (let i = 0, l = cbs.length; i &lt; l; i++) &#123; try &#123; // 调用注册到实例的事件回调 cbs[i].apply(vm, args) &#125; catch (e) &#123; handleError(e, vm, `event handler for \"$&#123;event&#125;\"`) &#125; &#125; &#125; return vm &#125; vm.$once监听一个自定义事件，但是只触发一次，在第一次触发之后移除监听器。 123456789101112Vue.prototype.$once = function (event: string, fn: Function): Component &#123; const vm: Component = this function on () &#123; // 移除监听器 vm.$off(event, on) // 调用回调 fn.apply(vm, arguments) &#125; on.fn = fn vm.$on(event, on) return vm&#125; 总结 用v-on注册的事件都会经过处理成render函数 注册的事件分为两大类，注册在普通HTML元素上的事件和注册在组件上的事件，但如果注册在组件上的事件有native修饰符，则会和普通HTML事件走相同的流程 普通HTML事件和native的组件事件最终会通过addEventListener绑定在元素上 组件事件则会通过$on去注册","path":"2018/07/08/Vue事件机制/","date":"07-08","excerpt":"源码分析Vue事件机制"},{"title":"JavaScript Debounce & Throttle","text":"探究一下函数节流和函数去抖的原理及实现 函数去抖（Debounce）对于那些频繁触发的事件，我们期望在某段时间內只触发一次，而不是每次触发都要执行回调 简单的说就是我们忽略掉多次触发的相同事件，只关注某一次触发 自己的实现：12345678910111213function debounce(fn, delay) &#123; let timer = null; return function (...args) &#123; let context = this; clearTimeout(timer); timer = setTimeout(() =&gt; &#123; fn.apply(context, args); &#125;, delay); &#125;&#125; 原理： 通过闭包存储timer，当连续触发事件时，上一次的定时器还未执行回调就会被下一次触发给清掉，所以只会最后一次触发才会执行回调 demo","path":"2018/03/18/JavaScript-Debounce-Throttle/","date":"03-18","excerpt":"探究一下函数节流和函数去抖的原理及实现"}]}