{"pages":[{"title":"404","text":"","path":"404/index.html","date":"02-25","excerpt":""},{"title":"search","text":"","path":"search/index.html","date":"02-25","excerpt":""}],"posts":[{"title":"JavaScript Debounce & Throttle","text":"探究一下函数节流和函数去抖的原理及实现 函数去抖（Debounce）对于那些频繁触发的事件，我们期望在某段时间內只触发一次，而不是每次触发都要执行回调 简单的说就是我们忽略掉多次触发的相同事件，只关注某一次触发 12345678910111213function debounce(fn, delay) &#123; let timer = null; return function (...args) &#123; let context = this; clearTimeout(timer); timer = setTimeout(() =&gt; &#123; fn.apply(context, args); &#125;, delay); &#125;&#125; 原理： 通过闭包存储timer，当连续触发事件时，上一次的定时器还未执行回调就会被下一次触发给清掉，所以只会最后一次触发才会执行回调 函数节流（Throttle）通过设置固定的执行频率，来降低函数的执行频率 12345678910111213141516171819202122function throttle(fn, cycle) &#123; let lastTime = null; let timer = null; return function (...args) &#123; const context = this; let now = new Date(); if (lastTime &amp;&amp; now &lt; lastTime + cycle) &#123; clearTimeout(timer); timer = setTimeout(() =&gt; &#123; lastTime = now; fn.apply(context, args); &#125;, cycle); &#125; else &#123; lastTime = now; fn.apply(this, args); &#125; &#125;&#125; 原理：通过闭包记录上个执行时间点，实现在周期性执行 demo","path":"2018/03/18/JavaScript-Debounce-Throttle/","date":"03-18","excerpt":"探究一下函数节流和函数去抖的原理及实现"}]}