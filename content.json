{"pages":[{"title":"404","text":"","path":"404/index.html","date":"02-25","excerpt":""},{"title":"search","text":"","path":"search/index.html","date":"02-25","excerpt":""}],"posts":[{"title":"vim笔记","text":"vim学习笔记 模式 ESC -&gt; 从当前模式转到normal模式 i -&gt; insert模式 : -&gt; command模式 移动 h -&gt; 光标向左 l -&gt; 光标向右 j -&gt; 光标向下 k -&gt; 光标向上 0 -&gt; 光标到行首 $ -&gt; 光标到行尾 ^ -&gt; 移动到本行第一个非空字符处 w -&gt; 向后一个词 5w -&gt; 向后五个词 b -&gt; 向前一个词 5b -&gt; 向前五个词 G -&gt; 到文件末尾 gg -&gt; 到文件开头 退出normal模式下，q -&gt; 退出vim，q! -&gt; 强制退出vim 删除字符normal模式下，x -&gt; 删除光标所在位置的字符 插入字符normal模式下，i -&gt; 进入编辑模式, ESC -&gt; 退出编辑模式","path":"2018/10/04/vim笔记/","date":"10-04","excerpt":"vim学习笔记"},{"title":"剑指offer-矩形覆盖","text":"Problem我们可以用2*1的小矩形横着或者竖着去覆盖更大的矩形。请问用n个2*1的小矩形无重叠地覆盖一个2*n的大矩形，总共有多少种方法？ Solution2*1的矩形只有1种方法2*2的矩形有2种方法一个2*n的矩形可以有两种拆分 2*1 + 2*(n-1) 2*2 + 2*(n-2) 所以这又是一个斐波那契问题 12345678910111213141516171819202122class Solution &#123;public: int rectCover(int number) &#123; if(number &lt;=2) &#123; return number; &#125; int prev1, prev2, sum; prev1 = 1; prev2 = 2; for(int i = 3; i &lt;= number; ++i) &#123; sum = prev1 + prev2; prev1 = prev2; prev2 = sum; &#125; return sum; &#125;&#125;;","path":"2018/09/01/剑指offer-矩形覆盖/","date":"09-01","excerpt":""},{"title":"剑指offer-跳台阶","text":"Problem一只青蛙一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个n级的台阶总共有多少种跳法（先后次序不同算不同的结果）。 Solution第n级台阶只能由第n-1阶台阶或第n-2阶台阶跳上来，所以这是一个斐波那契数列问题 123456789101112131415161718192021222324class Solution&#123;public: int jumpFloor(int number) &#123; if (number &lt;= 2) &#123; return number; &#125; int prev1, prev2, sum; prev1 = 1; prev2 = 2; sum = 0; for (int i = 3; i &lt;= number; ++i) &#123; sum = prev1 + prev2; prev1 = prev2; prev2 = sum; &#125; return sum; &#125;&#125;;","path":"2018/09/01/剑指offer-跳台阶/","date":"09-01","excerpt":""},{"title":"笔试题-画家小Q","text":"Problem画家小Q又开始他的艺术创作。小Q拿出了一块有NxM像素格的画板, 画板初始状态是空白的,用’X’表示。小Q有他独特的绘画技巧,每次小Q会选择一条斜线, 如果斜线的方向形如’/‘,即斜率为1,小Q会选择这条斜线中的一段格子,都涂画为蓝色,用’B’表示;如果对角线的方向形如’\\’,即斜率为-1,小Q会选择这条斜线中的一段格子,都涂画为黄色,用’Y’表示。如果一个格子既被蓝色涂画过又被黄色涂画过,那么这个格子就会变成绿色,用’G’表示。小Q已经有想画出的作品的样子, 请你帮他计算一下他最少需要多少次操作完成这幅画。 Instance123454 4YXXBXYGXXBYXBXXY 13 Solution思路：从左上角元素开始遍历，对于每一个元素 如果是Y就向右下寻找Y，遇到Y就变为X，遇到G就变为B，遇到B或X就返回 如果是B就向左下寻找B，遇到B就变为X，遇到G就变为Y，遇到Y或X就返回 如果是G就相当于A+B 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137#include &lt;iostream&gt;using namespace std;int main()&#123; int count = 0; int m, n; cin &gt;&gt; m &gt;&gt; n; char arr[m][n]; for (int i = 0; i &lt; m; i++) &#123; for (int j = 0; j &lt; n; j++) &#123; cin &gt;&gt; arr[i][j]; &#125; &#125; for (int x = 0; x &lt; m; x++) &#123; for (int y = 0; y &lt; n; y++) &#123; char curr = arr[x][y]; if (curr == 'Y') &#123; ++count; int a = x+1; int b = y+1; while(a &lt; m &amp;&amp; b &lt; n) &#123; if(arr[a][b] == 'Y') &#123; arr[a][b] = 'X'; a++; b++; &#125; else if (arr[a][b] == 'G') &#123; arr[a][b] = 'B'; a++; b++; &#125; else &#123; break; &#125; &#125; &#125; if (curr == 'B') &#123; ++count; int a = x+1; int b = y-1; while(a &lt; m &amp;&amp; b &gt;= 0) &#123; if(arr[a][b] == 'B') &#123; arr[a][b] = 'X'; a++; b--; &#125; else if (arr[a][b] == 'G') &#123; arr[a][b] = 'Y'; a++; b--; &#125; else &#123; break; &#125; &#125; &#125; if (curr == 'G') &#123; count += 2; int a = x+1; int b = y-1; while(a &lt; m &amp;&amp; b &lt; n) &#123; if(arr[a][b] == 'Y') &#123; arr[a][b] = 'X'; a++; b++; &#125; else if (arr[a][b] == 'G') &#123; arr[a][b] = 'B'; a++; b++; &#125; else &#123; break; &#125; &#125; int c = x+1; int d = y+1; while(c &lt; m &amp;&amp; d &gt;= 0) &#123; if(arr[c][d] == 'B') &#123; arr[c][d] = 'X'; c++; d--; &#125; else if (arr[c][d] == 'G') &#123; arr[c][d] = 'Y'; c++; d--; &#125; else &#123; break; &#125; &#125; &#125; &#125; &#125; cout &lt;&lt; count &lt;&lt;endl; return 0;&#125;;","path":"2018/08/31/笔试题-画家小Q/","date":"08-31","excerpt":""},{"title":"剑指offe-重建二叉树","text":"Problem输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。例如输入前序遍历序列{1,2,4,7,3,5,6,8}和中序遍历序列{4,7,2,1,5,3,8,6}，则重建二叉树并返回。 Solution常规思路123456789101112131415161718192021222324252627282930313233343536373839404142class Solution&#123;public: TreeNode* reConstructBinaryTree(vector&lt;int&gt; pre,vector&lt;int&gt; vin) &#123; if (vin.size() &lt;= 0 || pre.size() &lt;= 0) &#123; return NULL; &#125; TreeNode* root = new TreeNode(pre[0]); vector&lt;int&gt; leftPre, leftVin, rightPre, rightVin; bool isRootLeft = true; for (int i = 0; i &lt; vin.size(); ++i) &#123; if(vin[i] == pre[0]) &#123; isRootLeft = false; continue; &#125; if(isRootLeft) &#123; leftVin.push_back(vin[i]); leftPre.push_back(pre[i+1]); &#125; else &#123; rightVin.push_back(vin[i]); rightPre.push_back(pre[i]); &#125; &#125; root-&gt;left = reConstructBinaryTree(leftPre, leftVin); root-&gt;right = reConstructBinaryTree(rightPre, rightVin); return root; &#125;&#125;;","path":"2018/08/31/剑指offer-重建二叉树/","date":"08-31","excerpt":""},{"title":"剑指offer-从头到尾打印列表","text":"Problem输入一个链表，按链表值从尾到头的顺序返回一个ArrayList。 Solution 利用栈 1234567891011121314151617181920212223242526class Solution&#123;public: vector&lt;int&gt; printListFromTailToHead(ListNode* head) &#123; stack&lt;ListNode*&gt; nodes; vector&lt;int&gt; arrayList; ListNode* node = head; while(node != NULL) &#123; nodes.push(node); node = node-&gt;next; &#125; while(!nodes.empty()) &#123; node = nodes.top(); arrayList.push_back(node-&gt;val); nodes.pop(); &#125; return arrayList; &#125;&#125;; 递归 12345678910111213141516171819class Solution &#123;public: vector&lt;int&gt; arrayList; vector&lt;int&gt; printListFromTailToHead(ListNode* head) &#123; ListNode* node = head; if (node != NULL) &#123; if (node-&gt;next != NULL) &#123; printListFromTailToHead(node-&gt;next); &#125; arrayList.push_back(node-&gt;val); &#125; return arrayList; &#125;&#125;;","path":"2018/08/30/剑指offer-从头到尾打印列表/","date":"08-30","excerpt":""},{"title":"剑指offer--替换空格","text":"Problem请实现一个函数，将一个字符串中的每个空格替换成“%20”。例如，当字符串为We Are Happy.则经过替换之后的字符串为We%20Are%20Happy。 Solution正序遍历查找空格，逆序替换，这样这一减少移动元素的操作 1234567891011121314151617181920212223242526272829303132333435363738class Solution&#123;public: void replaceSpace(char *str, int length) &#123; if (str == NULL || length &lt;= 0) &#123; return; &#125; int space = 0; for (int i = 0; i &lt; length; ++i) &#123; if (str[i] == ' ') &#123; ++space; &#125; &#125; for (int i = length - 1; i &gt;= 0; --i) &#123; if (str[i] != ' ') &#123; str[i + 2 * space] = str[i]; &#125; else &#123; str[i + 2 * space] = '%'; str[i + 2 * space + 1] = '2'; str[i + 2 * space + 2] = '0'; &#125; &#125; return; &#125;&#125;","path":"2018/08/29/剑指offer-替换空格/","date":"08-29","excerpt":""},{"title":"剑指offer-二维数组中的查找","text":"Problem在一个二维数组中（每个一维数组的长度相同），每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。 Solution如果选取数组右上角的数字为起点，向左减小，向下增加 123456789101112131415161718192021222324252627class Solution&#123;public: bool Find(int target, vector&lt;vector&lt;int&gt; &gt; array) &#123; int rows = array.size(); int cols = array[0].size(); int i, j; int curr; for (i = 0, j = cols - 1; i &lt; rows &amp;&amp; j &gt;= 0;) &#123; curr = array[i][j]; if (target == curr) return true; else if (target &lt; curr) &#123; --j; continue; &#125; else ++i; &#125; return false; &#125;&#125;;","path":"2018/08/29/剑指offer-二维数组中的查找/","date":"08-29","excerpt":""},{"title":"剑指offer--斐波那契数列","text":"Problem大家都知道斐波那契数列，现在要求输入一个整数n，请你输出斐波那契数列的第n项（从0开始，第0项为0）。(n&lt;=39); Solution常规思路–&gt;递归，即利用F(n) = F(n-1) + F(n-2)，但这样做经常会超时 所以可以用循环优化，观察上面表达式，发现当前项只与前面两项有关，所以可以用变量将前两个值存起来 12345678910111213141516171819202122class Solution&#123;public: int Fibonacci(int n) &#123; if (n &lt;= 1) return n; int prev1 = 0; int prev2 = 1; int curr = 0; for (int i = 2; i &lt;= n; ++i) &#123; curr = prev1 + prev2; prev1 = prev2; prev2 = curr; &#125; return curr; &#125;&#125;","path":"2018/08/29/剑指offer-斐波那契数列/","date":"08-29","excerpt":""},{"title":"自己实现一个promise","text":"Step1: 定义Promise构造函数1234567891011121314151617181920function NewPromise(executor) &#123; const self = this; // [[PromiseStatus]]: resolved、rejected、pending this.status = 'pending'; // [[PromiseValue]] this.data = undefined; // promise可添加多个回调 this.resolveCallBaskList = []; this.rejectCallBackList = []; function resolve(value) &#123; &#125; function reject(error) &#123; &#125; executor(resolve, reject);&#125; Step2: 定义resolve和reject方法123456789101112131415161718192021222324252627282930313233343536function NewPromise(executor) &#123; const self = this; // [[PromiseStatus]]: resolved、rejected、pending this.status = 'pending'; // [[PromiseValue]] this.value = undefined; // promise可添加多个回调 this.resolveCallBaskList = []; this.rejectCallBackList = []; function resolve(value) &#123; // status不为pending则退出 if (self.status !== 'pending') return; self.status = 'resolved'; self.value = value; self.resolveCallBaskList.forEach(cb =&gt; &#123; cb(value); &#125;); &#125; function reject(error) &#123; // status不为pending则退出 if (self.status !== 'pending') return; self.status = 'rejected'; self.value = error; self.rejectCallBackList.forEach(cb =&gt; &#123; cb(error); &#125;) &#125; executor(resolve, reject);&#125; Step3: 定义then方法1234567891011121314151617181920212223NewPromise.prototype.then = function(resolveCb, rejectCb) &#123; const self = this; // check type if (typeof resolveCb !== 'function') &#123; resolveCb = function() &#123;&#125;; &#125; if (typeof rejectCb !== 'function') &#123; rejectCb = function() &#123;&#125;; &#125; if (self.status === 'resolved') &#123; resolveCb(self.value); &#125; if (self.status === 'rejected') &#123; rejectCb(self.error); &#125; if (self.status === 'pending') &#123; self.resolveCallBaskList.push(resolveCb); self.rejectCallBackList.push(rejectCb); &#125;&#125; 链式调用1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071NewPromise.prototype.then = function(resolveCb, rejectCb) &#123; const self = this; // check type if (typeof resolveCb !== 'function') &#123; resolveCb = function(value) &#123; return value; &#125;; &#125; if (typeof rejectCb !== 'function') &#123; rejectCb = function(error) &#123; throw err; &#125;; &#125; if (self.status === 'resolved') &#123; return new NewPromise(function(resolve, reject) &#123; try &#123; let res = resolveCb(self.value); if (res instanceof NewPromise) &#123; res.then(resolve, reject); &#125; else &#123; resolve(self.value); &#125; &#125; catch(err) &#123; reject(err); &#125; &#125;); &#125; if (self.status === 'rejected') &#123; return new NewPromise(function(resolve, reject) &#123; try &#123; let res = rejectCb(self.error); if (res instanceof NewPromise) &#123; res.then(resolve, reject); &#125; else &#123; resolve(self.value); &#125; &#125; catch(err) &#123; reject(err);· &#125; &#125;); &#125; if (self.status === 'pending') &#123; return new NewPromise(function(resolve, reject) &#123; self.resolveCallBaskList.push(function() &#123; let res = resolveCb(self.value); if (res instanceof NewPromise) &#123; res.then(resolve, reject); &#125; else &#123; resolve(self.value); &#125; &#125;); self.rejectCallBackList.push(function() &#123; let res = rejectCb(self.error); if (res instanceof NewPromise) &#123; res.then(resolve, reject); &#125; else &#123; resolve(self.value); &#125; &#125;); &#125;); &#125;&#125;","path":"2018/08/19/自己实现一个promise/","date":"08-19","excerpt":""},{"title":"JavaScript中的继承","text":"原型链继承12345678910111213141516171819202122function SuperType() &#123; this.name = 'Tom';&#125;SuperType.prototype.sayName = function() &#123; console.log(this.name);&#125;function SubType() &#123; this.age = 13;&#125;// 实现继承SubType.prototype = new SuperType();SubType.prototype.sayAge = function() &#123; console.log(this.age);&#125;var instance = new SubType('13');instance.sayAge(); // 13instance.sayName(); // Tom 原型链继承的问题 超类中的属性会被所有实例共享 创建子类型的实例时无法向超类传递参数 1234567891011121314function SuperType() &#123; this.colors = ['red', 'yellow', 'blue'];&#125;function SubType() &#123;&#125;SubType.prototype = new SuperType();var instance1 = new SubType();var instance2 = new SubType();instance1.colors.push('green');instance2.colors.pop(); // green 构造函数继承这种方法可以很好的解决上面的问题1234567891011121314151617181920function SuperType(counts) &#123; this.colors = ['red', 'yellow', 'blue']; this.counts = counts;&#125;function SubType(counts) &#123; // 继承属性 SuperType.call(this, counts);&#125;var instance1 = new SubType(1);var instance2 = new SubType(2);instance1.colors.push('green');instance2.colors.push('pink');console.log(instance1.colors); // [\"red\", \"yellow\", \"blue\", \"green\"]console.log(instance1.counts); // 1console.log(instance2.colors); // [\"red\", \"yellow\", \"blue\", \"pink\"]console.log(instance2.counts); // 2 构造函数继承的问题 方法都在构造函数中定义，无法达到函数复用的目的 组合式继承将原型链继承和构造函数继承组合起来 123456789101112131415161718192021222324252627282930313233function SuperType(name) &#123; this.name = name; this.colors = ['red', 'yellow'];&#125;SuperType.prototype.sayName = function() &#123; console.log(this.name);&#125;function SubType(name, age) &#123; // 继承属性 SuperType.call(this, name); this.age = age;&#125;// 继承方法SubType.prototype = new SuperType();SubType.prototype.constructor = SubType;SubType.prototype.sayAge = function() &#123; console.log(this.age);&#125;var instance1 = new SubType('Tom', 12);var instance2 = new SubType('Jone', 13);instance1.sayName(); // Tominstance1.sayAge(); // 12instance1.colors.push('green');console.log(instance1.colors); // [\"red\", \"yellow\", \"green\"]instance2.sayName(); // Joneinstance2.sayAge(); // 13instance2.colors.push('blue');console.log(instance2.colors); // [\"red\", \"yellow\", \"blue\"]","path":"2018/08/19/JavaScript中的继承/","date":"08-19","excerpt":""},{"title":"Vue响应式原理","text":"源码分析Vue响应式原理 初始化initState12345678910111213141516171819202122// 每个vue实例被创建的时候都会调用initStateexport function initState (vm: Component) &#123; // 用来存放观察者 vm._watchers = [] const opts = vm.$options // 初始化props if (opts.props) initProps(vm, opts.props) // 初始化实例方法 if (opts.methods) initMethods(vm, opts.methods) // 初始化data if (opts.data) &#123; initData(vm) &#125; else &#123; observe(vm._data = &#123;&#125;, true /* asRootData */) &#125; // 初始化computed if (opts.computed) initComputed(vm, opts.computed) // 初始化watch if (opts.watch &amp;&amp; opts.watch !== nativeWatch) &#123; initWatch(vm, opts.watch) &#125;&#125; initProps123456789101112131415161718192021222324252627282930313233343536373839404142434445464748function initProps (vm: Component, propsOptions: Object) &#123; const propsData = vm.$options.propsData || &#123;&#125; const props = vm._props = &#123;&#125; // cache prop keys so that future props updates can iterate using Array // instead of dynamic object key enumeration. const keys = vm.$options._propKeys = [] const isRoot = !vm.$parent // root instance props should be converted observerState.shouldConvert = isRoot for (const key in propsOptions) &#123; keys.push(key) // props校验 const value = validateProp(key, propsOptions, propsData, vm) /* istanbul ignore else */ if (process.env.NODE_ENV !== 'production') &#123; const hyphenatedKey = hyphenate(key) if (isReservedAttribute(hyphenatedKey) || config.isReservedAttr(hyphenatedKey)) &#123; warn( `\"$&#123;hyphenatedKey&#125;\" is a reserved attribute and cannot be used as component prop.`, vm ) &#125; // 使props响应化 defineReactive(props, key, value, () =&gt; &#123; if (vm.$parent &amp;&amp; !isUpdatingChildComponent) &#123; warn( `Avoid mutating a prop directly since the value will be ` + `overwritten whenever the parent component re-renders. ` + `Instead, use a data or computed property based on the prop's ` + `value. Prop being mutated: \"$&#123;key&#125;\"`, vm ) &#125; &#125;) &#125; else &#123; // 使props响应化 defineReactive(props, key, value) &#125; // static props are already proxied on the component's prototype // during Vue.extend(). We only need to proxy props defined at // instantiation here. if (!(key in vm)) &#123; proxy(vm, `_props`, key) &#125; &#125; observerState.shouldConvert = true&#125; initData1234567891011121314151617181920212223242526272829303132333435363738394041424344function initData (vm: Component) &#123; let data = vm.$options.data // 检测data data = vm._data = typeof data === 'function' ? getData(data, vm) : data || &#123;&#125; if (!isPlainObject(data)) &#123; data = &#123;&#125; process.env.NODE_ENV !== 'production' &amp;&amp; warn( 'data functions should return an object:\\n' + 'https://vuejs.org/v2/guide/components.html#data-Must-Be-a-Function', vm ) &#125; // proxy data on instance const keys = Object.keys(data) const props = vm.$options.props const methods = vm.$options.methods let i = keys.length // 检测data是否与props和methods重名 while (i--) &#123; const key = keys[i] if (process.env.NODE_ENV !== 'production') &#123; if (methods &amp;&amp; hasOwn(methods, key)) &#123; warn( `Method \"$&#123;key&#125;\" has already been defined as a data property.`, vm ) &#125; &#125; if (props &amp;&amp; hasOwn(props, key)) &#123; process.env.NODE_ENV !== 'production' &amp;&amp; warn( `The data property \"$&#123;key&#125;\" is already declared as a prop. ` + `Use prop default value instead.`, vm ) &#125; else if (!isReserved(key)) &#123; proxy(vm, `_data`, key) &#125; &#125; // observe data // 为data创建Observer observe(data, true /* asRootData */)&#125; initComputed12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091function initComputed (vm: Component, computed: Object) &#123; const watchers = vm._computedWatchers = Object.create(null) // computed properties are just getters during SSR const isSSR = isServerRendering() for (const key in computed) &#123; const userDef = computed[key] const getter = typeof userDef === 'function' ? userDef : userDef.get if (process.env.NODE_ENV !== 'production' &amp;&amp; getter == null) &#123; warn( `Getter is missing for computed property \"$&#123;key&#125;\".`, vm ) &#125; if (!isSSR) &#123; // create internal watcher for the computed property. // 非服务端渲染则为每个计算属性创建watcher watchers[key] = new Watcher( vm, getter || noop, noop, computedWatcherOptions ) &#125; // component-defined computed properties are already defined on the // component prototype. We only need to define computed properties defined // at instantiation here. if (!(key in vm)) &#123; defineComputed(vm, key, userDef) &#125; else if (process.env.NODE_ENV !== 'production') &#123; if (key in vm.$data) &#123; warn(`The computed property \"$&#123;key&#125;\" is already defined in data.`, vm) &#125; else if (vm.$options.props &amp;&amp; key in vm.$options.props) &#123; warn(`The computed property \"$&#123;key&#125;\" is already defined as a prop.`, vm) &#125; &#125; &#125;&#125;export function defineComputed ( target: any, key: string, userDef: Object | Function) &#123; const shouldCache = !isServerRendering() if (typeof userDef === 'function') &#123; sharedPropertyDefinition.get = shouldCache ? createComputedGetter(key) : userDef sharedPropertyDefinition.set = noop &#125; else &#123; sharedPropertyDefinition.get = userDef.get ? shouldCache &amp;&amp; userDef.cache !== false ? createComputedGetter(key) : userDef.get : noop sharedPropertyDefinition.set = userDef.set ? userDef.set : noop &#125; // 如果没有定义set，对计算属性赋值会报错 if (process.env.NODE_ENV !== 'production' &amp;&amp; sharedPropertyDefinition.set === noop) &#123; sharedPropertyDefinition.set = function () &#123; warn( `Computed property \"$&#123;key&#125;\" was assigned to but it has no setter.`, this ) &#125; &#125; Object.defineProperty(target, key, sharedPropertyDefinition)&#125;// 创建getterfunction createComputedGetter (key) &#123; return function computedGetter () &#123; const watcher = this._computedWatchers &amp;&amp; this._computedWatchers[key] if (watcher) &#123; if (watcher.dirty) &#123; watcher.evaluate() &#125; // 依赖收集 if (Dep.target) &#123; watcher.depend() &#125; return watcher.value &#125; &#125;&#125; initWatch1234567891011121314151617181920212223242526272829function initWatch (vm: Component, watch: Object) &#123; for (const key in watch) &#123; const handler = watch[key] if (Array.isArray(handler)) &#123; for (let i = 0; i &lt; handler.length; i++) &#123; createWatcher(vm, key, handler[i]) &#125; &#125; else &#123; createWatcher(vm, key, handler) &#125; &#125;&#125;function createWatcher ( vm: Component, keyOrFn: string | Function, handler: any, options?: Object) &#123; if (isPlainObject(handler)) &#123; options = handler handler = handler.handler &#125; if (typeof handler === 'string') &#123; handler = vm[handler] &#125; // 通过$watch创建watcher return vm.$watch(keyOrFn, handler, options)&#125;","path":"2018/08/09/Vue响应式原理/","date":"08-09","excerpt":"源码分析Vue响应式原理"},{"title":"策略模式","text":"基于JavaScript的设计模式第二篇 定义定义一系列的算法，把它们一个个封装起来，并且使它们能够相互替换策略模式的目的就是将算法的使用和算法的实现分开下面以表单校验为例子，实践一下策略模式 常规思路12345678910111213141516const form = &#123; name: 'Vermouth' phone: '13666666666'&#125;;function validataFunc(form) &#123; if (form.name === '') &#123; return false; &#125; if (!/(^1[3|5|8][0-9]&#123;9&#125;$)/.test(form.phone)) &#123; return false; &#125; return true;&#125; 这样做有很多缺点 校验函数复用性差 函数臃肿，if语句太多 弹性差 基于策略模式的表单校验12345678910111213141516171819202122232425262728293031323334const form = &#123; name: 'Vermouth', phone: '13666666666'&#125;// 校验规则集合const validataRules = &#123; isEmpty: val =&gt; val !== '', minLength: (val, limit) =&gt; val.length &gt;= limit, isPhone: val =&gt; /(^1[3|5|8][0-9]&#123;9&#125;$)/.test(val)&#125;;function Validator() &#123; this.result = null;&#125;Validator.prototype.add = function(val, rule, params) &#123; if (this.result === false) &#123; return; &#125; this.result = validataRules[rule](val, params);&#125;function validataFunc(form) &#123; let validator = new Validator(); validator.add(form.name, 'isEmpty'); validator.add(form.name, 'minLength', 6); validator.add(form.phone, 'isPhone'); return validator.result;&#125;validataFunc(form); 这样的好处是添加或者修改校验规则都会很方便","path":"2018/08/01/策略模式/","date":"08-01","excerpt":"基于JavaScript的设计模式第二篇"},{"title":"单例模式","text":"基于JavaScript的设计模式第一篇 定义保证一个类仅有一个实例，并提供一个访问他的全局访问点 简单实现为了实现一个类仅可以有一个实例，可以用一个字段来标识123456789101112131415161718192021222324const Singleton = function(name) &#123; this.name = name;&#125;;Singleton.prototype.sayName = function() &#123; console.log(this.name);&#125;;Singleton.getInstance = (function() &#123; let instance = null; return function(name) &#123; if (!instance) &#123; instance = new Singleton(name); &#125; return instance; &#125;&#125;());let a = Singleton.getInstance('a');let b = Singleton.getInstance('b');a.sayName(); // 'a'b.sayName(); // 'a'console.log(a === b); // true 可以看出确实只创建了一个实例，第二次并没有创建新的实例 改进1234567891011121314151617181920212223242526function Singleton(Fn) &#123; let instance = null; return function(...arg) &#123; if(!instance) &#123; instance = new Fn(...arg); &#125; return instance; &#125;;&#125;function Circle(radius) &#123; this.radius = radius;&#125;Circle.prototype.getArea = function() &#123; return 3.14 * this.radius * this.radius;&#125;let createCircle = Singleton(Circle);let circleA = createCircle(2);let circleB = createCircle(3);circleA.getArea(); // 12.56circleB.getArea(); // 12.56console.log(circleA === circleB); // true 这里实现了一个创建圆的单例模式，将Singleton分离出来，将真正的工厂函数作为回调传进去","path":"2018/07/31/单例模式/","date":"07-31","excerpt":"基于JavaScript的设计模式第一篇"},{"title":"排序算法","text":"总结一下各种常见的排序算法 冒泡排序交换相邻12345678910111213function bubbleSort(arr) &#123; const len = arr.length; for (let i = 0; i &lt; len; i++) &#123; for (let j = 0; j &lt; len; j++) &#123; if (arr[j] &gt; arr[j+1]) &#123; let swap = arr[j+1]; arr[j+1] = arr[j]; arr[j] = swap; &#125; &#125; &#125; return arr;&#125; 冒泡优化加一标志位，标示是否发生过交换123456789101112131415161718function betterBubble(arr) &#123; const len = arr.length; for (let i = 0; i &lt; len; i++) &#123; let flag = false; for (let j = 0; j &lt; len; j++) &#123; if (arr[j] &gt; arr[j+1]) &#123; let swap = arr[j+1]; arr[j+1] = arr[j]; arr[j] = swap; flag = true; &#125; &#125; if (!flag) &#123; break; &#125; &#125;&#125; 快速排序选定一个基准，小于基准的放左面，大于放右边12345678910111213141516171819function quickSort(arr) &#123; const len = arr.length; if (len &lt;= 1) return arr; let sign = arr[0]; let left = []; let right = []; for (let i = 1; i &lt; len; i++) &#123; if (arr[i] &gt; sign) &#123; right.push(arr[i]); &#125; else &#123; left.push(arr[i]); &#125; &#125; return quickSort(left).concat([sign], quickSort(right));&#125;","path":"2018/07/21/排序算法/","date":"07-21","excerpt":"总结一下各种常见的排序算法"},{"title":"Vuex源码学习","text":"Vuex是一个专门为Vue.js框架设计的、用于对Vue.js应用程序进行状态管理的库，它借鉴了Flux、redux的基本思想，将共享的数据抽离到全局，以一个单例存放，同时利用Vue.js的响应式机制来进行高效的状态管理与更新。正是因为Vuex使用了Vue.js内部的“响应式机制”，所以Vuex是一个专门为Vue.js设计并与之高度契合的框架![image][https://vuex.vuejs.org/flow.png] 引入Vuex在vue项目中我们通常会这样引入vuex12345678import Vuex from 'vuex';Vue.use(Vuex);// 将vuex注入到vue实例中new Vue(&#123; el: '#app', store&#125;); 这实际上是通过vuex提供的install123456789101112131415// installexport function install (_Vue) &#123; // 避免重复安装 if (Vue &amp;&amp; _Vue === Vue) &#123; if (process.env.NODE_ENV !== 'production') &#123; console.error( '[vuex] already installed. Vue.use(Vuex) should be called only once.' ) &#125; return &#125; Vue = _Vue // 将vuexInit混淆进vue的beforeCreate applyMixin(Vue)&#125; install做了两件事情，避免vuex重复安装和初始化vuex Vuex初始化12345678910111213function vuexInit () &#123; const options = this.$options if (options.store) &#123; this.$store = typeof options.store === 'function' ? options.store() : options.store &#125; else if (options.parent &amp;&amp; options.parent.$store) &#123; // 从父组件获取store，保证了单一数据源 this.$store = options.parent.$store &#125;&#125; 如果当前组件是root实例，则直接从options获取store，如果不是就获取父组件的store Store先来看store的constructor1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465constructor (options = &#123;&#125;) &#123; // Auto install if it is not done yet and `window` has `Vue`. // To allow users to avoid auto-installation in some cases, // this code should be placed here. See #731 if (!Vue &amp;&amp; typeof window !== 'undefined' &amp;&amp; window.Vue) &#123; install(window.Vue) &#125; if (process.env.NODE_ENV !== 'production') &#123; assert(Vue, `must call Vue.use(Vuex) before creating a store instance.`) assert(typeof Promise !== 'undefined', `vuex requires a Promise polyfill in this browser.`) assert(this instanceof Store, `store must be called with the new operator.`) &#125; const &#123; plugins = [], strict = false &#125; = options // store internal state this._committing = false // 存放action this._actions = Object.create(null) this._actionSubscribers = [] // 存放mutation this._mutations = Object.create(null) // 存放getter this._wrappedGetters = Object.create(null) // 存放module this._modules = new ModuleCollection(options) this._modulesNamespaceMap = Object.create(null) this._subscribers = [] this._watcherVM = new Vue() // bind commit and dispatch to self const store = this // 将dispatch和commit的this绑定为store，否则会指向vm const &#123; dispatch, commit &#125; = this this.dispatch = function boundDispatch (type, payload) &#123; return dispatch.call(store, type, payload) &#125; this.commit = function boundCommit (type, payload, options) &#123; return commit.call(store, type, payload, options) &#125; // strict mode this.strict = strict const state = this._modules.root.state // 初始化根module，同时递归初始化子module // 收集所有getter, action, mutation（包括子module） installModule(this, state, [], this._modules.root) // 通过vm使store响应式化 resetStoreVM(this, state) // 调用插件 plugins.forEach(plugin =&gt; plugin(this)) // devtools if (Vue.config.devtools) &#123; devtoolPlugin(this) &#125;&#125; 接下来看看vuex如何安装module 123456789101112131415161718192021222324252627282930313233343536373839404142// installModulefunction installModule (store, rootState, path, module, hot) &#123; const isRoot = !path.length const namespace = store._modules.getNamespace(path) // register in namespace map // 如果开启了命名空间就将模块注册到map里 if (module.namespaced) &#123; store._modulesNamespaceMap[namespace] = module &#125; // set state if (!isRoot &amp;&amp; !hot) &#123; const parentState = getNestedState(rootState, path.slice(0, -1)) const moduleName = path[path.length - 1] store._withCommit(() =&gt; &#123; Vue.set(parentState, moduleName, module.state) &#125;) &#125; const local = module.context = makeLocalContext(store, namespace, path) module.forEachMutation((mutation, key) =&gt; &#123; const namespacedType = namespace + key registerMutation(store, namespacedType, mutation, local) &#125;) module.forEachAction((action, key) =&gt; &#123; const type = action.root ? key : namespace + key const handler = action.handler || action registerAction(store, type, handler, local) &#125;) module.forEachGetter((getter, key) =&gt; &#123; const namespacedType = namespace + key registerGetter(store, namespacedType, getter, local) &#125;) module.forEachChild((child, key) =&gt; &#123; installModule(store, rootState, path.concat(key), child, hot) &#125;)&#125;","path":"2018/07/18/Vuex源码学习/","date":"07-18","excerpt":"Vuex是一个专门为Vue.js框架设计的、用于对Vue.js应用程序进行状态管理的库，它借鉴了Flux、redux的基本思想，将共享的数据抽离到全局，以一个单例存放，同时利用Vue.js的响应式机制来进行高效的状态管理与更新。正是因为Vuex使用了Vue.js内部的“响应式机制”，所以Vuex是一个专门为Vue.js设计并与之高度契合的框架"},{"title":"Vue事件机制","text":"源码分析Vue事件机制vue 的事件都是通过v-on指令进行监听，这会涉及到vue是如何将template转化为render的，这里先不做讨论12345678910111213// parse.jsexport const onRE = /^@|^v-on:/...else if (onRE.test(name)) &#123; // v-on name = name.replace(onRE, '') /** * name: 事件名 * value: 回调函数 * modifiers: 事件修饰符 */ addHandler(el, name, value, modifiers, false, warn)&#125;... 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152// addHandlerexport function addHandler ( el: ASTElement, name: string, value: string, modifiers: ?ASTModifiers, important?: boolean, warn?: Function) &#123; // prevent和passive两个修饰符不能同时存在于同一个节点 if ( process.env.NODE_ENV !== 'production' &amp;&amp; warn &amp;&amp; modifiers &amp;&amp; modifiers.prevent &amp;&amp; modifiers.passive ) &#123; warn( 'passive and prevent can\\'t be used together. ' + 'Passive handler can\\'t prevent default event.' ) &#125; // check capture modifier if (modifiers &amp;&amp; modifiers.capture) &#123; delete modifiers.capture name = '!' + name // mark the event as captured &#125; if (modifiers &amp;&amp; modifiers.once) &#123; delete modifiers.once name = '~' + name // mark the event as once &#125; /* istanbul ignore if */ if (modifiers &amp;&amp; modifiers.passive) &#123; delete modifiers.passive name = '&amp;' + name // mark the event as passive &#125; let events if (modifiers &amp;&amp; modifiers.native) &#123; // 对native的事件特殊处理 delete modifiers.native events = el.nativeEvents || (el.nativeEvents = &#123;&#125;) &#125; else &#123; events = el.events || (el.events = &#123;&#125;) &#125; const newHandler = &#123; value, modifiers &#125; const handlers = events[name] // 将回调注册到el上 if (Array.isArray(handlers)) &#123; important ? handlers.unshift(newHandler) : handlers.push(newHandler) &#125; else if (handlers) &#123; events[name] = important ? [newHandler, handlers] : [handlers, newHandler] &#125; else &#123; events[name] = newHandler &#125;&#125; 在合成AST时，会对events进行处理1234567// event handlersif (el.events) &#123; data += `$&#123;genHandlers(el.events, false, state.warn)&#125;,`&#125;if (el.nativeEvents) &#123; data += `$&#123;genHandlers(el.nativeEvents, true, state.warn)&#125;,`&#125; 12345678910111213141516171819202122232425// genHandlersexport function genHandlers ( events: ASTElementHandlers, isNative: boolean, warn: Function): string &#123; // 对native特殊化处理 let res = isNative ? 'nativeOn:&#123;' : 'on:&#123;' // 将事件以字符串的形式拼接在一个对象里 for (const name in events) &#123; const handler = events[name] // 提示用contextmenu代替click.right if (process.env.NODE_ENV !== 'production' &amp;&amp; name === 'click' &amp;&amp; handler &amp;&amp; handler.modifiers &amp;&amp; handler.modifiers.right ) &#123; warn( `Use \"contextmenu\" instead of \"click.right\" since right clicks ` + `do not actually fire \"click\" events.` ) &#125; res += `\"$&#123;name&#125;\":$&#123;genHandler(name, handler)&#125;,` &#125; return res.slice(0, -1) + '&#125;'&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960// genHandlerfunction genHandler ( name: string, handler: ASTElementHandler | Array&lt;ASTElementHandler&gt;): string &#123; // 没有回调则用一个空函数代替 if (!handler) &#123; return 'function()&#123;&#125;' &#125; // 回调是以数组传入 if (Array.isArray(handler)) &#123; return `[$&#123;handler.map(handler =&gt; genHandler(name, handler)).join(',')&#125;]` &#125; const isMethodPath = simplePathRE.test(handler.value) const isFunctionExpression = fnExpRE.test(handler.value) if (!handler.modifiers) &#123; return isMethodPath || isFunctionExpression ? handler.value : `function($event)&#123;$&#123;handler.value&#125;&#125;` // inline statement &#125; else &#123; let code = '' let genModifierCode = '' const keys = [] // 对事件修饰符进行处理 for (const key in handler.modifiers) &#123; if (modifierCode[key]) &#123; genModifierCode += modifierCode[key] // left/right if (keyCodes[key]) &#123; keys.push(key) &#125; &#125; else if (key === 'exact') &#123; const modifiers: ASTModifiers = (handler.modifiers: any) genModifierCode += genGuard( ['ctrl', 'shift', 'alt', 'meta'] .filter(keyModifier =&gt; !modifiers[keyModifier]) .map(keyModifier =&gt; `$event.$&#123;keyModifier&#125;Key`) .join('||') ) &#125; else &#123; keys.push(key) &#125; &#125; if (keys.length) &#123; code += genKeyFilter(keys) &#125; // Make sure modifiers like prevent and stop get executed after key filtering if (genModifierCode) &#123; code += genModifierCode &#125; const handlerCode = isMethodPath ? handler.value + '($event)' : isFunctionExpression ? `($&#123;handler.value&#125;)($event)` : handler.value return `function($event)&#123;$&#123;code&#125;$&#123;handlerCode&#125;&#125;` &#125;&#125; 在Virtual DOM 渲染成真实DOM时会绑定事件1234567891011121314151617181920212223242526272829let target: HTMLElementfunction add ( event: string, handler: Function, once: boolean, capture: boolean, passive: boolean) &#123; if (once) &#123; const oldHandler = handler const _target = target // save current target element in closure handler = function (ev) &#123; const res = arguments.length === 1 ? oldHandler(ev) : oldHandler.apply(null, arguments) if (res !== null) &#123; remove(event, handler, capture, _target) &#125; &#125; &#125; target.addEventListener( event, handler, supportsPassive ? &#123; capture, passive &#125; : capture )&#125; 事件APIVue为我们提供了四个api, 分别是$on$off$once$emit 初始化事件123456789101112export function initEvents (vm: Component) &#123; // vm实例上存放event的地方 vm._events = Object.create(null) // 用来标志是否存在钩子 vm._hasHookEvent = false // _parentListeners里放的是注册在组件上的且不是native的事件 const listeners = vm.$options._parentListeners if (listeners) &#123; updateComponentListeners(vm, listeners) &#125;&#125; vm.$on用来监听当前实例上的自定义事件，该事件由$emit触发123456789101112131415161718Vue.prototype.$on = function (event: string | Array&lt;string&gt;, fn: Function): Component &#123; const vm: Component = this // 如果有多个自定义事件，会以数组的形式传递 if (Array.isArray(event)) &#123; // 遍历数组，$on每个事件 for (let i = 0, l = event.length; i &lt; l; i++) &#123; this.$on(event[i], fn) &#125; &#125; else &#123; // 在实例的_vm上注册事件，一个事件可有多个回调 (vm._events[event] || (vm._events[event] = [])).push(fn) // 有钩子时，标志位变为true，如：hook:beforeDestroy if (hookRE.test(event)) &#123; vm._hasHookEvent = true &#125; &#125; return vm&#125; vm.$off用来移除自定义事件监听器1234567891011121314151617181920212223242526272829303132333435363738Vue.prototype.$off = function (event?: string | Array&lt;string&gt;, fn?: Function): Component &#123; const vm: Component = this // 如果没有提供参数，则移除实例上所有监听器 if (!arguments.length) &#123; vm._events = Object.create(null) return vm &#125; // 移除该事件所有监听器 if (Array.isArray(event)) &#123; for (let i = 0, l = event.length; i &lt; l; i++) &#123; this.$off(event[i], fn) &#125; return vm &#125; // 特定事件 const cbs = vm._events[event] if (!cbs) &#123; return vm &#125; if (arguments.length === 1) &#123; vm._events[event] = null return vm &#125; // 如果制定了回调函数，则只移除该回调相关的监听器 if (fn) &#123; let cb let i = cbs.length while (i--) &#123; cb = cbs[i] if (cb === fn || cb.fn === fn) &#123; cbs.splice(i, 1) break &#125; &#125; &#125; return vm&#125; vm.$emit触发当前实例的事件12345678910111213141516171819202122232425262728293031Vue.prototype.$emit = function (event: string): Component &#123; const vm: Component = this // 避免使用驼峰式的事件名 if (process.env.NODE_ENV !== 'production') &#123; const lowerCaseEvent = event.toLowerCase() if (lowerCaseEvent !== event &amp;&amp; vm._events[lowerCaseEvent]) &#123; tip( `Event \"$&#123;lowerCaseEvent&#125;\" is emitted in component ` + `$&#123;formatComponentName(vm)&#125; but the handler is registered for \"$&#123;event&#125;\". ` + `Note that HTML attributes are case-insensitive and you cannot use ` + `v-on to listen to camelCase events when using in-DOM templates. ` + `You should probably use \"$&#123;hyphenate(event)&#125;\" instead of \"$&#123;event&#125;\".` ) &#125; &#125; let cbs = vm._events[event] if (cbs) &#123; cbs = cbs.length &gt; 1 ? toArray(cbs) : cbs // emit参数数组化 const args = toArray(arguments, 1) for (let i = 0, l = cbs.length; i &lt; l; i++) &#123; try &#123; // 调用注册到实例的事件回调 cbs[i].apply(vm, args) &#125; catch (e) &#123; handleError(e, vm, `event handler for \"$&#123;event&#125;\"`) &#125; &#125; &#125; return vm &#125; vm.$once监听一个自定义事件，但是只触发一次，在第一次触发之后移除监听器。 123456789101112Vue.prototype.$once = function (event: string, fn: Function): Component &#123; const vm: Component = this function on () &#123; // 移除监听器 vm.$off(event, on) // 调用回调 fn.apply(vm, arguments) &#125; on.fn = fn vm.$on(event, on) return vm&#125; 总结 用v-on注册的事件都会经过处理成render函数 注册的事件分为两大类，注册在普通HTML元素上的事件和注册在组件上的事件，但如果注册在组件上的事件有native修饰符，则会和普通HTML事件走相同的流程 普通HTML事件和native的组件事件最终会通过addEventListener绑定在元素上 组件事件则会通过$on去注册","path":"2018/07/08/Vue事件机制/","date":"07-08","excerpt":"源码分析Vue事件机制"},{"title":"JavaScript Debounce & Throttle","text":"探究一下函数节流和函数去抖的原理及实现 函数去抖（Debounce）对于那些频繁触发的事件，我们期望在某段时间內只触发一次，而不是每次触发都要执行回调 简单的说就是我们忽略掉多次触发的相同事件，只关注某一次触发 自己的实现：12345678910111213function debounce(fn, delay) &#123; let timer = null; return function (...args) &#123; let context = this; clearTimeout(timer); timer = setTimeout(() =&gt; &#123; fn.apply(context, args); &#125;, delay); &#125;&#125; 原理： 通过闭包存储timer，当连续触发事件时，上一次的定时器还未执行回调就会被下一次触发给清掉，所以只会最后一次触发才会执行回调 函数节流（Throttle）通过设置固定的执行频率，来降低函数的执行频率 自己的实现:12345678910111213141516171819202122function throttle(fn, cycle) &#123; let lastTime = null; let timer = null; return function (...args) &#123; const context = this; let now = new Date(); if (lastTime &amp;&amp; now &lt; lastTime + cycle) &#123; clearTimeout(timer); timer = setTimeout(() =&gt; &#123; lastTime = now; fn.apply(context, args); &#125;, cycle); &#125; else &#123; lastTime = now; fn.apply(this, args); &#125; &#125;&#125; 原理：通过闭包记录上个执行时间点，实现在周期性执行 demo","path":"2018/03/18/JavaScript-Debounce-Throttle/","date":"03-18","excerpt":"探究一下函数节流和函数去抖的原理及实现"}]}